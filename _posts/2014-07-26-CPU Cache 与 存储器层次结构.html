---
layout: post
title: "CPU Cache 与 存储器层次结构"
category: "c和os"
---

<div style="line-height: 1.6; font-family: Helvetica Neue, Arial, Hiragino Sans GB, STHeiti, Microsoft YaHei, WenQuanYi Micro Hei, SimSun, Song, sans-serif;">
<h2 style="font-family: inherit; font-weight: bold; line-height: 1.1; color: inherit; margin-top: 30px; margin-bottom: 20px; font-size: 30px;">1. 分层的存储器</h2>
<p style="margin: 0 0 10px; line-height: 1.6; white-space: pre-wrap; word-wrap: break-word;"><img alt="Alt text" class="en-media" longdesc="./1404030834275.png" name="ee264f1e-62bb-4d9f-88fa-9daa1f4e160d" src="https://www.evernote.com/shard/s133/sh/3bb6ac50-c660-49d9-b214-88b6357e35df/939f9b1f174859d1a917945d9e33db77/res/ee264f1e-62bb-4d9f-88fa-9daa1f4e160d/1404030834275.png?resizeSmall&amp;width=832" style="border: 0; max-width: 100%; border-radius: 8px;"/></p>
<p style="margin: 0 0 10px; line-height: 1.6; white-space: pre-wrap; word-wrap: break-word;">第 k 层是第 k+1 层的 cache, 存储 k+1 层数据的一个子集.</p>
<table style="border-collapse: collapse; border-spacing: 0; margin-bottom: 20px;">
<thead>
<tr>
<th style="padding: 8px; line-height: 20px; text-align: left; vertical-align: top; border: 1px solid #DDD;"></th>
<th style="padding: 8px; line-height: 20px; text-align: left; vertical-align: top; border: 1px solid #DDD;">访问时间</th>
</tr>
</thead>
<tbody>
<tr>
<td style="padding: 8px; line-height: 20px; text-align: left; vertical-align: top; border: 1px solid #DDD;">寄存器</td>
<td style="padding: 8px; line-height: 20px; text-align: left; vertical-align: top; border: 1px solid #DDD;">个(ns)</td>
</tr>
<tr>
<td style="padding: 8px; line-height: 20px; text-align: left; vertical-align: top; border: 1px solid #DDD;">缓存</td>
<td style="padding: 8px; line-height: 20px; text-align: left; vertical-align: top; border: 1px solid #DDD;">十(ns)</td>
</tr>
<tr>
<td style="padding: 8px; line-height: 20px; text-align: left; vertical-align: top; border: 1px solid #DDD;">内存</td>
<td style="padding: 8px; line-height: 20px; text-align: left; vertical-align: top; border: 1px solid #DDD;">百(ns)</td>
</tr>
<tr>
<td style="padding: 8px; line-height: 20px; text-align: left; vertical-align: top; border: 1px solid #DDD;">硬盘</td>
<td style="padding: 8px; line-height: 20px; text-align: left; vertical-align: top; border: 1px solid #DDD;">个(ms，1ms = 10^6 ns)</td>
</tr>
</tbody>
</table>
<h2 style="font-family: inherit; font-weight: bold; line-height: 1.1; color: inherit; margin-top: 30px; margin-bottom: 20px; font-size: 30px;">2. CPU cache</h2>
<p style="margin: 0 0 10px; line-height: 1.6; white-space: pre-wrap; word-wrap: break-word;">分层，每个CPU有各自的L1/L2缓存，共享的L3缓存。</p>
<p style="margin: 0 0 10px; line-height: 1.6; white-space: pre-wrap; word-wrap: break-word;">Cache 的基本组成单位是<code style="font-family: Menlo, Monaco, Consolas, Courier New, monospace; font-size: 90%; padding: 0 4px; color: #c7254e; background-color: #f9f2f4; white-space: nowrap; border-radius: 4px; margin: 0 4px;">line</code>，cache 和内存交换数据的基本单位称为一个 <code style="font-family: Menlo, Monaco, Consolas, Courier New, monospace; font-size: 90%; padding: 0 4px; color: #c7254e; background-color: #f9f2f4; white-space: nowrap; border-radius: 4px; margin: 0 4px;">block</code>，一个<code style="font-family: Menlo, Monaco, Consolas, Courier New, monospace; font-size: 90%; padding: 0 4px; color: #c7254e; background-color: #f9f2f4; white-space: nowrap; border-radius: 4px; margin: 0 4px;">line</code> 包含一个 <code style="font-family: Menlo, Monaco, Consolas, Courier New, monospace; font-size: 90%; padding: 0 4px; color: #c7254e; background-color: #f9f2f4; white-space: nowrap; border-radius: 4px; margin: 0 4px;">block</code> 和其他信息. 当数据从内存读入时，不会只load一个byte，而是装入整个<code style="font-family: Menlo, Monaco, Consolas, Courier New, monospace; font-size: 90%; padding: 0 4px; color: #c7254e; background-color: #f9f2f4; white-space: nowrap; border-radius: 4px; margin: 0 4px;">block</code>, 它通常是32或64字节。</p>
<blockquote style="padding: 15px 20px; margin: 0 0 15px 0; font-size: 14px; border-left: 5px solid #ddd; background-color: rgba(102, 128, 153, 0.05);">
<p style="margin: 0 0 10px; margin-bottom: 0; line-height: 1.6; font-size: 14px; font-weight: 300; white-space: pre-wrap; word-wrap: break-word;"><code style="font-family: Menlo, Monaco, Consolas, Courier New, monospace; font-size: 90%; padding: 0 4px; color: #c7254e; background-color: #fff; white-space: nowrap; border-radius: 3px; margin: 0 4px;">Line</code> 和 <code style="font-family: Menlo, Monaco, Consolas, Courier New, monospace; font-size: 90%; padding: 0 4px; color: #c7254e; background-color: #fff; white-space: nowrap; border-radius: 3px; margin: 0 4px;">Block</code> 这两个术语经常混用, 当出现"Cache Line 的长度是32字节"这种说法时, 很显然指的是 Block.</p>
</blockquote><p style="margin: 0 0 10px; line-height: 1.6; white-space: pre-wrap; word-wrap: break-word;">所有对内存的读/写都要经过 cache。</p>
<p style="margin: 0 0 10px; line-height: 1.6; white-space: pre-wrap; word-wrap: break-word;">缓存不命中的种类:</p>
<ol style="margin-top: 0; margin-bottom: 10px; line-height: 1.6;">
<li style="line-height: 1.6;">cold miss, 缓存没数据</li>
<li style="line-height: 1.6;">conflict miss, 加载数据到 cache 时, 硬件通常使用严格的放置策略, 而不是随便找一个空位使用, 因为这样的查找效率很低. 因此可能出现不同的数据被映射到同一个 cache line 的情况, 即使还有空间也会出现不命中.</li>
<li style="line-height: 1.6;">capacity miss, 缓存空间不够.</li>
</ol>
<h3 style="font-family: inherit; font-weight: bold; line-height: 1.1; color: inherit; margin-top: 30px; margin-bottom: 20px; font-size: 24px;">cache 的组成结构:</h3>
<p style="margin: 0 0 10px; line-height: 1.6; white-space: pre-wrap; word-wrap: break-word;"><img alt="Alt text" class="en-media" longdesc="./1404033629695.png" name="69e1d6af-5edb-45a2-860d-56aebaba9c52" src="https://www.evernote.com/shard/s133/sh/3bb6ac50-c660-49d9-b214-88b6357e35df/939f9b1f174859d1a917945d9e33db77/res/69e1d6af-5edb-45a2-860d-56aebaba9c52/1404033629695.png?resizeSmall&amp;width=832" style="border: 0; max-width: 100%; border-radius: 8px;"/></p>
<p style="margin: 0 0 10px; line-height: 1.6; white-space: pre-wrap; word-wrap: break-word;">内存地址在逻辑上被划分为这3个部分:<br/><img alt="Alt text" class="en-media" longdesc="./1404033972526.png" name="daa2a3bc-bc65-4a2f-8436-4f268ffced6d" src="https://www.evernote.com/shard/s133/sh/3bb6ac50-c660-49d9-b214-88b6357e35df/939f9b1f174859d1a917945d9e33db77/res/daa2a3bc-bc65-4a2f-8436-4f268ffced6d/1404033972526.png?resizeSmall&amp;width=832" style="border: 0; max-width: 100%; border-radius: 8px;"/></p>
<p style="margin: 0 0 10px; line-height: 1.6; white-space: pre-wrap; word-wrap: break-word;">假设 CPU 需要读取某个地址上的一个字, 在 cache 中是这样定位的:</p>
<ol style="margin-top: 0; margin-bottom: 10px; line-height: 1.6;">
<li style="line-height: 1.6;"><p style="margin: 0 0 10px; line-height: 1.6; white-space: pre-wrap; word-wrap: break-word;">查找 Group<br/>内存地址到 Group 的映射是严格确定的, 即有 <span style="display:inline-block;margin:0"><span></span><span><span style="white-space: nowrap;"><span style="width: 1.193em; display: inline-block;"><span style="display: inline-block; position: relative; width: 0.955em; height: 0px; font-size: 120%;"><span style="position: absolute; clip: rect(1.313em 1000.003em 2.384em -0.533em); top: -2.199em; left: 0.003em;"><span><span><span style="display: inline-block; position: relative; width: 0.896em; height: 0px;"><span style="position: absolute; clip: rect(1.729em 1000.003em 2.741em -0.533em); top: -2.557em; left: 0.003em;"><span style="font-family:STIXGeneral-Regular, serif;">2</span><span style="display: inline-block; width: 0px; height: 2.562em;"></span></span><span style="position: absolute; top: -2.676em; left: 0.539em;"><span style="font-size: 70.7%; font-family:STIXGeneral-Italic, serif;">s</span><span style="display: inline-block; width: 0px; height: 2.265em;"></span></span></span></span></span><span style="display: inline-block; width: 0px; height: 2.205em;"></span></span></span><span style="border-left-width: 0.004em; border-left-style: solid; display: inline-block; overflow: hidden; width: 0px; height: 1.004em; vertical-align: -0.068em;"></span></span></span></span></span> 个 Group, 因此由组索引可直接定位 Group. 这一步很快;</p>
</li>
<li style="line-height: 1.6;"><p style="margin: 0 0 10px; line-height: 1.6; white-space: pre-wrap; word-wrap: break-word;">查找 Cache Line<br/>长度为 t 的标记位相当于 Cache Line 在 Gropu 中的序号。对定位到的 Group 中所有的 Cache Line, 将其标志位与内存地址的标记位一一比对, 如果匹配且设置了有效位, 则说明 Line 匹配。 这也意味着填充缓存时可以任意在该 Group 中挑选一个空闲的  Line 存放. 这一步的效率较低;</p>
</li>
<li style="line-height: 1.6;"><p style="margin: 0 0 10px; line-height: 1.6; white-space: pre-wrap; word-wrap: break-word;">抽取字<br/>根据物理地址中的 块偏移, 在找到的 Line 所存储的 block 中的对应位置抽取字即可.</p>
</li>
</ol>
<p style="margin: 0 0 10px; line-height: 1.6; white-space: pre-wrap; word-wrap: break-word;">当每个 Group 只有一个 Cache Line 时, 这样的结构称为<code style="font-family: Menlo, Monaco, Consolas, Courier New, monospace; font-size: 90%; padding: 0 4px; color: #c7254e; background-color: #f9f2f4; white-space: nowrap; border-radius: 4px; margin: 0 4px;">直接映射</code>. 此时 cache 的定位跳过了第二步, 但它很容易造成 conflict miss.</p>
<p style="margin: 0 0 10px; line-height: 1.6; white-space: pre-wrap; word-wrap: break-word;">当所有的 Cache Line 组成一个 Group 时, 称为<code style="font-family: Menlo, Monaco, Consolas, Courier New, monospace; font-size: 90%; padding: 0 4px; color: #c7254e; background-color: #f9f2f4; white-space: nowrap; border-radius: 4px; margin: 0 4px;">全相联</code>. 此时 conflict miss 的概率最低, 可以利用所有 cache 空间, 但缺点是查找很慢, 因此该策略只适用于小规模的缓存.</p>
<p style="margin: 0 0 10px; line-height: 1.6; white-space: pre-wrap; word-wrap: break-word;">每个 Group 中有 n 个 Cache Line 时, 称为<code style="font-family: Menlo, Monaco, Consolas, Courier New, monospace; font-size: 90%; padding: 0 4px; color: #c7254e; background-color: #f9f2f4; white-space: nowrap; border-radius: 4px; margin: 0 4px;">n 路组相联</code>, 这种结构在 查找速度 和 conflict miss 间做了平衡.</p>
<h2 style="font-family: inherit; font-weight: bold; line-height: 1.1; color: inherit; margin-top: 30px; margin-bottom: 20px; font-size: 30px;">3. 程序的局部性</h2>
<ol style="margin-top: 0; margin-bottom: 10px; line-height: 1.6;">
<li style="line-height: 1.6;"><strong style="font-weight: bold;">时间局部性 (temporal locality)</strong>: 一个被引用的内存地址很可能在随后被多次使用;</li>
<li style="line-height: 1.6;"><strong style="font-weight: bold;">空间局部性 (spatial locality)</strong>: 如果程序引用了某个地址, 那么程序很有可能在随后引用它附近的地址.</li>
</ol>
<p style="margin: 0 0 10px; line-height: 1.6; white-space: pre-wrap; word-wrap: break-word;">Cache 本身的思想就是利用<code style="font-family: Menlo, Monaco, Consolas, Courier New, monospace; font-size: 90%; padding: 0 4px; color: #c7254e; background-color: #f9f2f4; white-space: nowrap; border-radius: 4px; margin: 0 4px;">时间局部性</code>减少热点数据的访问时间 ; Cache 和 内存 之间以 block 为单位交换数据的行为利用了程序的 <code style="font-family: Menlo, Monaco, Consolas, Courier New, monospace; font-size: 90%; padding: 0 4px; color: #c7254e; background-color: #f9f2f4; white-space: nowrap; border-radius: 4px; margin: 0 4px;">空间局部性</code>;  现代 CPU 也会根据 <code style="font-family: Menlo, Monaco, Consolas, Courier New, monospace; font-size: 90%; padding: 0 4px; color: #c7254e; background-color: #f9f2f4; white-space: nowrap; border-radius: 4px; margin: 0 4px;">空间局部性</code> prefetch 正在使用的内存地址附近的数据到缓存中.  因此, 编写具有良好局部性的代码的根本目的是为了 <strong style="font-weight: bold;">提高缓存命中率</strong>,  低命中率的缓存不但会增加数据的获取时间, 更会造成频繁的淘汰.</p>
<p style="margin: 0 0 10px; line-height: 1.6; white-space: pre-wrap; word-wrap: break-word;">一个常见的提高代码空间局部性的技巧是 始终按数据的存放顺序以步长为1的方式引用数据. 这一点在多维数组的循环时显得更加重要, C 以行优先顺序存储数组, 如果采用一列一列的扫描方式就类似随机访问了, 当数组规模比较大时将显著降低缓存的命中率.</p>
<h2 style="font-family: inherit; font-weight: bold; line-height: 1.1; color: inherit; margin-top: 30px; margin-bottom: 20px; font-size: 30px;">4. MESI协议</h2>
<p style="margin: 0 0 10px; line-height: 1.6; white-space: pre-wrap; word-wrap: break-word;">TODO</p>
<h2 style="font-family: inherit; font-weight: bold; line-height: 1.1; color: inherit; margin-top: 30px; margin-bottom: 20px; font-size: 30px;">5. False sharing</h2>
<p style="margin: 0 0 10px; line-height: 1.6; white-space: pre-wrap; word-wrap: break-word;">两个变量AB同时存储在一个<code style="font-family: Menlo, Monaco, Consolas, Courier New, monospace; font-size: 90%; padding: 0 4px; color: #c7254e; background-color: #f9f2f4; white-space: nowrap; border-radius: 4px; margin: 0 4px;">line</code>中，CPU1需要频繁更新A，CPU2需要频繁访问B(读取或更新)，它们在自己的私有 cache 中都拥有该缓存行的一个副本。根据MESI协议，CPU1更新A时需要invalidate其他CPU中的该行，这就造成了CPU2每次访问B都无法命中cache，每次都需从内存载入，大大降低了性能。这种现象称为<code style="font-family: Menlo, Monaco, Consolas, Courier New, monospace; font-size: 90%; padding: 0 4px; color: #c7254e; background-color: #f9f2f4; white-space: nowrap; border-radius: 4px; margin: 0 4px;">False sharing</code>。</p>
<p style="margin: 0 0 10px; line-height: 1.6; white-space: pre-wrap; word-wrap: break-word;">解决办法是使用 内存padding(即使用额外的变量填充) 增加 A 或 B 的长度, 将它们分散到两个不同的 Cache Line 中.</p>
<p style="margin: 0 0 10px; line-height: 1.6; white-space: pre-wrap; word-wrap: break-word;"><strong style="font-weight: bold;"> <a href="http://mechanical-sympathy.blogspot.com/2011/07/false-sharing.html" style="background: transparent;" target="_blank">一个 java 的例子:</a> </strong><br/>对 32位 Hotspot JVM 而言, 每个对象都有 2-word (8 byte) 长度的对象头, 数组有一个额外的 word 保存长度. 对象内部的属性根据内存对齐的要求按照如下顺序重新排列布局:</p>
<ol style="margin-top: 0; margin-bottom: 10px; line-height: 1.6;">
<li style="line-height: 1.6;">doubles (8) and longs (8)</li>
<li style="line-height: 1.6;">ints (4) and floats (4)</li>
<li style="line-height: 1.6;">shorts (2) and chars (2)</li>
<li style="line-height: 1.6;">booleans (1) and bytes (1)</li>
<li style="line-height: 1.6;">references (4/8)</li>
<li style="line-height: 1.6;"><p style="margin: 0 0 10px; line-height: 1.6; white-space: pre-wrap; word-wrap: break-word;">&lt;repeat for sub-class fields&gt;

</p>
</li>
</ol>
<p style="margin: 0 0 10px; line-height: 1.6; white-space: pre-wrap; word-wrap: break-word;">因此, 对于通常 64 bytes 长的 cache line 而言, 如果需要两个对象分布在不同的 cache line 中, 只需要在任意一个对象的末尾用 7 个 long (56 bytes) 当做padding 即可.</p>
<p style="margin: 0 0 10px; line-height: 1.6; white-space: pre-wrap; word-wrap: break-word;">测试代码:</p>
<pre style="overflow: initial; font-family: Menlo, Monaco, Consolas, Courier New, monospace; font-size: 14px; display: block; padding: 0; margin: 0 0 10px; line-height: 1.6; word-break: break-all; word-wrap: break-word; color: #333333; background-color: #f5f5f5; border: none; border-radius: 0; white-space: pre-wrap; background: transparent;" xml:space="preserve"><code style="font-family: Menlo, Monaco, Consolas, Courier New, monospace; font-size: inherit; padding: 1em; color: #f8f8f2; background-color: transparent; white-space: pre-wrap; border-radius: 8px; display: block; background: #23241f; margin: 0 4px;"><span style="color: #F92672;">public</span> <span style="color: #F92672;">final</span> <span><span style="color: #66d9ef;">class</span> <span style="color: #f8f8f2;">FalseSharing</span> <span style="color: #F92672;">implements</span> <span style="color: #a6e22e; font-style: italic;">Runnable</span></span>{
    <span style="color: #75715e;">// 思路: 用一个对象数组, 每个元素用一个线程循环改变其内部一个字段的值,</span>
    <span style="color: #75715e;">// 分别测试有 padding 和无 padding 的性能</span>

    <span style="color: #F92672;">public</span> <span style="color: #F92672;">final</span> <span style="color: #F92672;">static</span> <span style="color: #F92672;">int</span> NUM_THREADS = <span style="color: #ae81ff;">4</span>; <span style="color: #75715e;">// 数组元素数量, 亦即线程数</span>
    <span style="color: #F92672;">public</span> <span style="color: #F92672;">final</span> <span style="color: #F92672;">static</span> <span style="color: #F92672;">long</span> ITERATIONS = <span style="color: #ae81ff;">500</span>L * <span style="color: #ae81ff;">1000</span>L * <span style="color: #ae81ff;">1000</span>L; <span style="color: #75715e;">// 循环数</span>
    <span style="color: #F92672;">private</span> <span style="color: #F92672;">final</span> <span style="color: #F92672;">int</span> arrayIndex;

    <span style="color: #F92672;">private</span> <span style="color: #F92672;">static</span> VolatileLong[] longs = <span style="color: #F92672;">new</span> VolatileLong[NUM_THREADS];
    <span style="color: #75715e;">// 数组初始化</span>
    <span style="color: #F92672;">static</span>
    {
        <span style="color: #F92672;">for</span> (<span style="color: #F92672;">int</span> i = <span style="color: #ae81ff;">0</span>; i &lt; longs.length; i++)
        {
            longs[i] = <span style="color: #F92672;">new</span> VolatileLong();
        }
    }

    <span style="color: #F92672;">public</span> <span style="color: #a6e22e;">FalseSharing</span>(<span style="color: #F92672;">final</span> <span style="color: #F92672;">int</span> arrayIndex){
        <span style="color: #F92672;">this</span>.arrayIndex = arrayIndex;
    }

    <span style="color: #F92672;">public</span> <span style="color: #F92672;">static</span> <span style="color: #F92672;">void</span> <span style="color: #a6e22e;">main</span>(<span style="color: #F92672;">final</span> String[] args) <span style="color: #F92672;">throws</span> Exception{
        <span style="color: #F92672;">final</span> <span style="color: #F92672;">long</span> start = System.nanoTime();
        runTest();
        System.out.println(<span style="color: #e6db74;">"duration = "</span> + (System.nanoTime() - start));
    }

    <span style="color: #F92672;">private</span> <span style="color: #F92672;">static</span> <span style="color: #F92672;">void</span> <span style="color: #a6e22e;">runTest</span>() <span style="color: #F92672;">throws</span> InterruptedException{
        Thread[] threads = <span style="color: #F92672;">new</span> Thread[NUM_THREADS];

        <span style="color: #F92672;">for</span> (<span style="color: #F92672;">int</span> i = <span style="color: #ae81ff;">0</span>; i &lt; threads.length; i++){
            threads[i] = <span style="color: #F92672;">new</span> Thread(<span style="color: #F92672;">new</span> FalseSharing(i));
        }

        <span style="color: #F92672;">for</span> (Thread t : threads){
            t.start();
        }

        <span style="color: #F92672;">for</span> (Thread t : threads){
            t.join();
        }
    }

    <span style="color: #F92672;">public</span> <span style="color: #F92672;">void</span> <span style="color: #a6e22e;">run</span>(){
        <span style="color: #F92672;">long</span> i = ITERATIONS + <span style="color: #ae81ff;">1</span>;
        <span style="color: #F92672;">while</span> (<span style="color: #ae81ff;">0</span> != --i){
            longs[arrayIndex].value = i;
        }
    }

    <span style="color: #F92672;">public</span> <span style="color: #F92672;">final</span> <span style="color: #F92672;">static</span> <span><span style="color: #66d9ef;">class</span> <span style="color: #a6e22e; font-style: italic;">VolatileLong</span>
    </span>{
        <span style="color: #F92672;">public</span> <span style="color: #F92672;">volatile</span> <span style="color: #F92672;">long</span> value = <span style="color: #ae81ff;">0</span>L;
        <span style="color: #F92672;">public</span> <span style="color: #F92672;">long</span> p1, p2, p3, p4, p5, p6; <span style="color: #75715e;">// &lt;----- padding</span>

        <span style="color: #75715e;">// 注意, java 7 会优化掉无用的变量, 需要用一个方法比如 sum使用这些变量</span>
    }
}
</code></pre>
<p style="margin: 0 0 10px; line-height: 1.6; white-space: pre-wrap; word-wrap: break-word;">结果对比如下:<br/><img alt="Alt text" class="en-media" longdesc="./1404554293302.png" name="b6b85d08-1c3e-45d3-9943-25d464a0bc28" src="https://www.evernote.com/shard/s133/sh/3bb6ac50-c660-49d9-b214-88b6357e35df/939f9b1f174859d1a917945d9e33db77/res/b6b85d08-1c3e-45d3-9943-25d464a0bc28/1404554293302.png?resizeSmall&amp;width=832" style="border: 0; max-width: 100%; border-radius: 8px;"/></p>
</div>