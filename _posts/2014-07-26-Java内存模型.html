---
layout: post
title: "Java内存模型"
category: "并发"
---

<div style="line-height: 1.6; font-family: Helvetica Neue, Arial, Hiragino Sans GB, STHeiti, Microsoft YaHei, WenQuanYi Micro Hei, SimSun, Song, sans-serif;">
<h2 style="font-family: inherit; font-weight: bold; line-height: 1.1; color: inherit; margin-top: 30px; margin-bottom: 20px; font-size: 30px;">1. 什么是 JMM？</h2>
<p style="margin: 0 0 10px; line-height: 1.6; white-space: pre-wrap; word-wrap: break-word;">JMM屏蔽掉底层不同平台的差异，在语言层面为程序员提供一个抽象的内存模型，它的核心是一系列关于<code style="font-family: Menlo, Monaco, Consolas, Courier New, monospace; font-size: 90%; padding: 0 4px; color: #c7254e; background-color: #f9f2f4; white-space: nowrap; border-radius: 8px; margin: 0 4px;">指令乱序</code>的规则，java语言层面上提供的<code style="font-family: Menlo, Monaco, Consolas, Courier New, monospace; font-size: 90%; padding: 0 4px; color: #c7254e; background-color: #f9f2f4; white-space: nowrap; border-radius: 8px; margin: 0 4px;">volatile</code>和<code style="font-family: Menlo, Monaco, Consolas, Courier New, monospace; font-size: 90%; padding: 0 4px; color: #c7254e; background-color: #f9f2f4; white-space: nowrap; border-radius: 8px; margin: 0 4px;">monitor机制</code>是其中的两个重点。</p>
<p style="margin: 0 0 10px; line-height: 1.6; white-space: pre-wrap; word-wrap: break-word;">有两个方面会导致指令的乱序执行：</p>
<ol style="margin-top: 0; margin-bottom: 10px; line-height: 1.6;">
<li style="line-height: 1.6;"><strong style="font-weight: bold;">编译器重排序</strong></li>
<li style="line-height: 1.6;"><strong style="font-weight: bold;">CPU 重排序</strong></li>
</ol>
<h2 style="font-family: inherit; font-weight: bold; line-height: 1.1; color: inherit; margin-top: 30px; margin-bottom: 20px; font-size: 30px;">2. 编译器的重排序</h2>
<p style="margin: 0 0 10px; line-height: 1.6; white-space: pre-wrap; word-wrap: break-word;">编译器（对 java 而言是 JIT 编译器）在保证 <strong style="font-weight: bold;">单线程语义正确</strong> 的前提下，为了优化性能，可以任意对指令重新排序。这对单线程不会产生影响，但在并发环境下就可能导致问题。</p>
<h3 style="font-family: inherit; font-weight: bold; line-height: 1.1; color: inherit; margin-top: 30px; margin-bottom: 20px; font-size: 24px;">2.1 Compiler Memory Barrier</h3>
<p style="margin: 0 0 10px; line-height: 1.6; white-space: pre-wrap; word-wrap: break-word;">在其他未提供统一内存模型的语言中(如C)，需要使用<code style="font-family: Menlo, Monaco, Consolas, Courier New, monospace; font-size: 90%; padding: 0 4px; color: #c7254e; background-color: #f9f2f4; white-space: nowrap; border-radius: 8px; margin: 0 4px;">Compiler Memory Barrier</code>显式告诉编译器停止重排序：以该Barrier为分割线，Barrier上方的指令不可以重排序到下方，反之亦然。</p>
<p style="margin: 0 0 10px; line-height: 1.6; white-space: pre-wrap; word-wrap: break-word;">C中，不同的编译器需要不同的指令：</p>
<pre style="overflow: initial; font-family: Menlo, Monaco, Consolas, Courier New, monospace; font-size: 14px; display: block; padding: 0; margin: 0 0 10px; line-height: 1.6; word-break: break-all; word-wrap: break-word; color: #333333; background-color: #f5f5f5; border: none; border-radius: 0; white-space: pre-wrap; background: transparent;" xml:space="preserve"><code style="font-family: Menlo, Monaco, Consolas, Courier New, monospace; font-size: inherit; padding: 1em; color: #f8f8f2; background-color: transparent; white-space: pre-wrap; border-radius: 8px; display: block; background: #23241f; margin: 0 4px;">__asm__ __volatile__ (<span style="color: #e6db74;">""</span> ::: <span style="color: #e6db74;">"memory"</span>); <span style="color: #75715e;">// GNU</span>
__memory_barrier(); <span style="color: #75715e;">// Intel ECC Compiler</span>
_ReadWriteBarrier(); <span style="color: #75715e;">// Microsoft Visual C++</span>
</code></pre>
<p style="margin: 0 0 10px; line-height: 1.6; white-space: pre-wrap; word-wrap: break-word;">这些指令是针对编译器的，不会对CPU起作用。</p>
<h3 style="font-family: inherit; font-weight: bold; line-height: 1.1; color: inherit; margin-top: 30px; margin-bottom: 20px; font-size: 24px;">2.2 JMM 对编译器重排序的规定</h3>
<p style="margin: 0 0 10px; line-height: 1.6; white-space: pre-wrap; word-wrap: break-word;">JMM在为编译器重排序定义了如下规则（NO表示不可重排序）：</p>
<table style="border-collapse: collapse; border-spacing: 0; margin-bottom: 20px;">
<thead>
<tr>
<th style="padding: 8px; line-height: 20px; text-align: left; vertical-align: top; border: 1px solid #DDD;">1nd \\\ 2nd</th>
<th style="padding: 8px; line-height: 20px; text-align: left; vertical-align: top; border: 1px solid #DDD;">Normal Load / Normal Store</th>
<th style="padding: 8px; line-height: 20px; text-align: left; vertical-align: top; border: 1px solid #DDD;">Volatile Load / Monitor Enter</th>
<th style="padding: 8px; line-height: 20px; text-align: left; vertical-align: top; border: 1px solid #DDD;">Volatile Store / Monitor Exit</th>
</tr>
</thead>
<tbody>
<tr>
<td style="padding: 8px; line-height: 20px; text-align: left; vertical-align: top; border: 1px solid #DDD;">Normal Load / Normal Store</td>
<td style="padding: 8px; line-height: 20px; text-align: left; vertical-align: top; border: 1px solid #DDD;"></td>
<td style="padding: 8px; line-height: 20px; text-align: left; vertical-align: top; border: 1px solid #DDD;"></td>
<td style="padding: 8px; line-height: 20px; text-align: left; vertical-align: top; border: 1px solid #DDD;">NO</td>
</tr>
<tr>
<td style="padding: 8px; line-height: 20px; text-align: left; vertical-align: top; border: 1px solid #DDD;">Volatile Load / Monitor Enter</td>
<td style="padding: 8px; line-height: 20px; text-align: left; vertical-align: top; border: 1px solid #DDD;">NO</td>
<td style="padding: 8px; line-height: 20px; text-align: left; vertical-align: top; border: 1px solid #DDD;">NO</td>
<td style="padding: 8px; line-height: 20px; text-align: left; vertical-align: top; border: 1px solid #DDD;">NO</td>
</tr>
<tr>
<td style="padding: 8px; line-height: 20px; text-align: left; vertical-align: top; border: 1px solid #DDD;">Volatile store / Monitor Exit</td>
<td style="padding: 8px; line-height: 20px; text-align: left; vertical-align: top; border: 1px solid #DDD;"></td>
<td style="padding: 8px; line-height: 20px; text-align: left; vertical-align: top; border: 1px solid #DDD;">NO</td>
<td style="padding: 8px; line-height: 20px; text-align: left; vertical-align: top; border: 1px solid #DDD;">NO</td>
</tr>
</tbody>
</table>
<blockquote style="padding: 15px 20px; margin: 0 0 15px 0; font-size: 14px; border-left: 5px solid #ddd; background-color: rgba(102, 128, 153, 0.05);">
<p style="margin: 0 0 10px; margin-bottom: 0; line-height: 1.6; font-size: 14px; font-weight: 300; white-space: pre-wrap; word-wrap: break-word;"><code style="font-family: Menlo, Monaco, Consolas, Courier New, monospace; font-size: 90%; padding: 0 4px; color: #c7254e; background-color: #fff; white-space: nowrap; border-radius: 3px; margin: 0 4px;">Monitor Enter</code> 和 <code style="font-family: Menlo, Monaco, Consolas, Courier New, monospace; font-size: 90%; padding: 0 4px; color: #c7254e; background-color: #fff; white-space: nowrap; border-radius: 3px; margin: 0 4px;">Monitor Exit</code> 分别对应 <code style="font-family: Menlo, Monaco, Consolas, Courier New, monospace; font-size: 90%; padding: 0 4px; color: #c7254e; background-color: #fff; white-space: nowrap; border-radius: 3px; margin: 0 4px;">Sychronized</code> 块的进入和离开。</p>
</blockquote><p style="margin: 0 0 10px; line-height: 1.6; white-space: pre-wrap; word-wrap: break-word;">简单地说就是在3类地方禁止编译器重排序：</p>
<p style="margin: 0 0 10px; line-height: 1.6; white-space: pre-wrap; word-wrap: break-word;"><img alt="Alt text" class="en-media" longdesc="./1403762671001.png" name="d6e30d03-880d-4961-b607-eb924270f492" src="/assets/img/d08f4d58e9f50ecfc929b199829526c4.png" style="border: 0; max-width: 100%; border-radius: 8px;"/></p>
<ol style="margin-top: 0; margin-bottom: 10px; line-height: 1.6;">
<li style="line-height: 1.6;"><code style="font-family: Menlo, Monaco, Consolas, Courier New, monospace; font-size: 90%; padding: 0 4px; color: #c7254e; background-color: #f9f2f4; white-space: nowrap; border-radius: 8px; margin: 0 4px;">Volatile 读</code> &amp; <code style="font-family: Menlo, Monaco, Consolas, Courier New, monospace; font-size: 90%; padding: 0 4px; color: #c7254e; background-color: #f9f2f4; white-space: nowrap; border-radius: 8px; margin: 0 4px;">Sychronized 块的进入</code> 与 <strong style="font-weight: bold;">后续任意读写</strong> 不可重排；</li>
<li style="line-height: 1.6;"><code style="font-family: Menlo, Monaco, Consolas, Courier New, monospace; font-size: 90%; padding: 0 4px; color: #c7254e; background-color: #f9f2f4; white-space: nowrap; border-radius: 8px; margin: 0 4px;">Volatile 写</code> &amp; <code style="font-family: Menlo, Monaco, Consolas, Courier New, monospace; font-size: 90%; padding: 0 4px; color: #c7254e; background-color: #f9f2f4; white-space: nowrap; border-radius: 8px; margin: 0 4px;">Sychronized 块的离开</code> 与 <strong style="font-weight: bold;">之前任意读写</strong> 不可重排；</li>
<li style="line-height: 1.6;"><code style="font-family: Menlo, Monaco, Consolas, Courier New, monospace; font-size: 90%; padding: 0 4px; color: #c7254e; background-color: #f9f2f4; white-space: nowrap; border-radius: 8px; margin: 0 4px;">Volatile 写</code> &amp; <code style="font-family: Menlo, Monaco, Consolas, Courier New, monospace; font-size: 90%; padding: 0 4px; color: #c7254e; background-color: #f9f2f4; white-space: nowrap; border-radius: 8px; margin: 0 4px;">Sychronized 块的离开</code> 与后续 <code style="font-family: Menlo, Monaco, Consolas, Courier New, monospace; font-size: 90%; padding: 0 4px; color: #c7254e; background-color: #f9f2f4; white-space: nowrap; border-radius: 8px; margin: 0 4px;">Volatile 读</code> &amp; <code style="font-family: Menlo, Monaco, Consolas, Courier New, monospace; font-size: 90%; padding: 0 4px; color: #c7254e; background-color: #f9f2f4; white-space: nowrap; border-radius: 8px; margin: 0 4px;">Sychronized 块的进入</code> 不可重排。</li>
</ol>
<p style="margin: 0 0 10px; line-height: 1.6; white-space: pre-wrap; word-wrap: break-word;">这几处和后面提到的 CPU指令重排序 是一致的。</p>
<h2 style="font-family: inherit; font-weight: bold; line-height: 1.1; color: inherit; margin-top: 30px; margin-bottom: 20px; font-size: 30px;">3. CPU 重排序（<code style="font-family: Menlo, Monaco, Consolas, Courier New, monospace; font-size: 90%; padding: 0 4px; color: #c7254e; background-color: #f9f2f4; white-space: nowrap; border-radius: 8px; margin: 0 4px;">Memory Reordering</code>）</h2>
<p style="margin: 0 0 10px; line-height: 1.6; white-space: pre-wrap; word-wrap: break-word;"><code style="font-family: Menlo, Monaco, Consolas, Courier New, monospace; font-size: 90%; padding: 0 4px; color: #c7254e; background-color: #f9f2f4; white-space: nowrap; border-radius: 8px; margin: 0 4px;">Memory Rerdering</code>指的是在 CPU 在执行程序时， 对内存地址的 <code style="font-family: Menlo, Monaco, Consolas, Courier New, monospace; font-size: 90%; padding: 0 4px; color: #c7254e; background-color: #f9f2f4; white-space: nowrap; border-radius: 8px; margin: 0 4px;">load</code> 和 <code style="font-family: Menlo, Monaco, Consolas, Courier New, monospace; font-size: 90%; padding: 0 4px; color: #c7254e; background-color: #f9f2f4; white-space: nowrap; border-radius: 8px; margin: 0 4px;">store</code> 指令 <strong style="font-weight: bold;">实际完成的顺序 与 发起指令的顺序 不一致</strong></p>
<h3 style="font-family: inherit; font-weight: bold; line-height: 1.1; color: inherit; margin-top: 30px; margin-bottom: 20px; font-size: 24px;">3.1 为什么会出现<code style="font-family: Menlo, Monaco, Consolas, Courier New, monospace; font-size: 90%; padding: 0 4px; color: #c7254e; background-color: #f9f2f4; white-space: nowrap; border-radius: 8px; margin: 0 4px;">Memory Reordering</code>？</h3>
<p style="margin: 0 0 10px; line-height: 1.6; white-space: pre-wrap; word-wrap: break-word;">CPU 为了避免慢速的内存访问拖累指令的执行速度，一个常用的技巧是：将对cache或内存的<code style="font-family: Menlo, Monaco, Consolas, Courier New, monospace; font-size: 90%; padding: 0 4px; color: #c7254e; background-color: #f9f2f4; white-space: nowrap; border-radius: 8px; margin: 0 4px;">load</code>/<code style="font-family: Menlo, Monaco, Consolas, Courier New, monospace; font-size: 90%; padding: 0 4px; color: #c7254e; background-color: #f9f2f4; white-space: nowrap; border-radius: 8px; margin: 0 4px;">store</code>指令缓冲至 CPU 内部的 pipeline，对其（异步地）优化后再执行，如重排序(比如先执行命中 cache 的指令，或者将地址相近的指令放在一起执行) / 合并对同一地址的读或写 / 直接从 write buffer 中 load 数据等等，以尽量避免 cache miss，并减少对内存的访问。这是一个生产者消费者模型。</p>
<p style="margin: 0 0 10px; line-height: 1.6; white-space: pre-wrap; word-wrap: break-word;">此外，为了充分利用多级流水线，CPU 的 <code style="font-family: Menlo, Monaco, Consolas, Courier New, monospace; font-size: 90%; padding: 0 4px; color: #c7254e; background-color: #f9f2f4; white-space: nowrap; border-radius: 8px; margin: 0 4px;">预测执行 speculative execution</code> 机制会根据以往的执行情况，在一个判断条件还没得到结果时预先执行概率大的分支并缓存结果，如果条件判断通过则直接使用该中间结果，这也会导致指令的乱序。</p>
<p style="margin: 0 0 10px; line-height: 1.6; white-space: pre-wrap; word-wrap: break-word;"><img alt="Alt text" class="en-media" longdesc="./1403925881122.png" name="21102672-fa20-41fd-889e-58c2eb93baf5" src="/assets/img/fd9868241dc03d1519b75f4ed3ad547b.png" style="border: 0; max-width: 100%; border-radius: 8px;"/></p>
<p style="margin: 0 0 10px; line-height: 1.6; white-space: pre-wrap; word-wrap: break-word;">如图所示，CPU 的执行单元与 cache 之间还存在着各种 buffer，<code style="font-family: Menlo, Monaco, Consolas, Courier New, monospace; font-size: 90%; padding: 0 4px; color: #c7254e; background-color: #f9f2f4; white-space: nowrap; border-radius: 8px; margin: 0 4px;">load store</code>指令会先进入这些 buffer 中排队。当指令一旦被 <code style="font-family: Menlo, Monaco, Consolas, Courier New, monospace; font-size: 90%; padding: 0 4px; color: #c7254e; background-color: #f9f2f4; white-space: nowrap; border-radius: 8px; margin: 0 4px;">flush</code> 到 cache ，MESI 缓存一致性协议将保证数据对所有 CPU 可见。</p>
<h3 style="font-family: inherit; font-weight: bold; line-height: 1.1; color: inherit; margin-top: 30px; margin-bottom: 20px; font-size: 24px;">3.2 什么情况允许<code style="font-family: Menlo, Monaco, Consolas, Courier New, monospace; font-size: 90%; padding: 0 4px; color: #c7254e; background-color: #f9f2f4; white-space: nowrap; border-radius: 8px; margin: 0 4px;">Memory Reordering</code>？</h3>
<p style="margin: 0 0 10px; line-height: 1.6; white-space: pre-wrap; word-wrap: break-word;">CPU 进行 <code style="font-family: Menlo, Monaco, Consolas, Courier New, monospace; font-size: 90%; padding: 0 4px; color: #c7254e; background-color: #f9f2f4; white-space: nowrap; border-radius: 8px; margin: 0 4px;">Memory Reordering</code> 的前提是保证单线程下语义的正确性，这和编译器重排序遵循的规则是一样的。更进一步的，对于存在<code style="font-family: Menlo, Monaco, Consolas, Courier New, monospace; font-size: 90%; padding: 0 4px; color: #c7254e; background-color: #f9f2f4; white-space: nowrap; border-radius: 8px; margin: 0 4px;">数据依赖性</code>的指令不允许重排序。</p>
<p style="margin: 0 0 10px; line-height: 1.6; white-space: pre-wrap; word-wrap: break-word;">数据依赖分下列三种类型：</p>
<ol style="margin-top: 0; margin-bottom: 10px; line-height: 1.6;">
<li style="line-height: 1.6;">写后读    <code style="font-family: Menlo, Monaco, Consolas, Courier New, monospace; font-size: 90%; padding: 0 4px; color: #c7254e; background-color: #f9f2f4; white-space: nowrap; border-radius: 8px; margin: 0 4px;">a = 1;b = a;</code>    写一个变量之后，再读这个位置。</li>
<li style="line-height: 1.6;">写后写    <code style="font-family: Menlo, Monaco, Consolas, Courier New, monospace; font-size: 90%; padding: 0 4px; color: #c7254e; background-color: #f9f2f4; white-space: nowrap; border-radius: 8px; margin: 0 4px;">a = 1;a = 2;</code>    写一个变量之后，再写这个变量。</li>
<li style="line-height: 1.6;">读后写    <code style="font-family: Menlo, Monaco, Consolas, Courier New, monospace; font-size: 90%; padding: 0 4px; color: #c7254e; background-color: #f9f2f4; white-space: nowrap; border-radius: 8px; margin: 0 4px;">a = b;b = 1;</code>    读一个变量之后，再写这个变量。</li>
</ol>
<p style="margin: 0 0 10px; line-height: 1.6; white-space: pre-wrap; word-wrap: break-word;">上面三种情况，只要重排序两个操作的执行顺序，程序的执行结果将会被改变。</p>
<p style="margin: 0 0 10px; line-height: 1.6; white-space: pre-wrap; word-wrap: break-word;">对于存在<code style="font-family: Menlo, Monaco, Consolas, Courier New, monospace; font-size: 90%; padding: 0 4px; color: #c7254e; background-color: #f9f2f4; white-space: nowrap; border-radius: 8px; margin: 0 4px;">控制依赖性</code>的代码也可能发生重排序，如：</p>
<pre style="overflow: initial; font-family: Menlo, Monaco, Consolas, Courier New, monospace; font-size: 14px; display: block; padding: 0; margin: 0 0 10px; line-height: 1.6; word-break: break-all; word-wrap: break-word; color: #333333; background-color: #f5f5f5; border: none; border-radius: 0; white-space: pre-wrap; background: transparent;" xml:space="preserve"><code style="font-family: Menlo, Monaco, Consolas, Courier New, monospace; font-size: inherit; padding: 1em; color: #f8f8f2; background-color: transparent; white-space: pre-wrap; border-radius: 8px; display: block; background: #23241f; margin: 0 4px;"><span style="color: #F92672;">if</span>(ready)
    b = a * a
</code></pre>
<p style="margin: 0 0 10px; line-height: 1.6; white-space: pre-wrap; word-wrap: break-word;">假如对 ready 的 load 发生了 cache miss，为了不阻塞指令执行， CPU 可能会采用<code style="font-family: Menlo, Monaco, Consolas, Courier New, monospace; font-size: 90%; padding: 0 4px; color: #c7254e; background-color: #f9f2f4; white-space: nowrap; border-radius: 8px; margin: 0 4px;">猜测执行</code>的手段，预先 load a，并计算<code style="font-family: Menlo, Monaco, Consolas, Courier New, monospace; font-size: 90%; padding: 0 4px; color: #c7254e; background-color: #f9f2f4; white-space: nowrap; border-radius: 8px; margin: 0 4px;">a * a</code>的结果放入 buffer；待 ready 的 load 完成后，如果为 true，再将计算结果取出，执行 b 的 store 动作。</p>
<h3 style="font-family: inherit; font-weight: bold; line-height: 1.1; color: inherit; margin-top: 30px; margin-bottom: 20px; font-size: 24px;">3.3 CPU Memory Barrier</h3>
<p style="margin: 0 0 10px; line-height: 1.6; white-space: pre-wrap; word-wrap: break-word;">CPU 自身只能保证单线程下的serial 的语义，但在并发程序中，我们经常需要 <strong style="font-weight: bold;">保证多线程之间内存操作的有序性</strong>，这依赖我们手动在合适的地方插入内存屏障，禁止单线程内某种形式的重排序。</p>
<p style="margin: 0 0 10px; line-height: 1.6; white-space: pre-wrap; word-wrap: break-word;"><code style="font-family: Menlo, Monaco, Consolas, Courier New, monospace; font-size: 90%; padding: 0 4px; color: #c7254e; background-color: #f9f2f4; white-space: nowrap; border-radius: 8px; margin: 0 4px;">Load</code> <code style="font-family: Menlo, Monaco, Consolas, Courier New, monospace; font-size: 90%; padding: 0 4px; color: #c7254e; background-color: #f9f2f4; white-space: nowrap; border-radius: 8px; margin: 0 4px;">Store</code> 两两组合，一共存在4种乱序，因此对应的有4种 barrier：</p>
<ol style="margin-top: 0; margin-bottom: 10px; line-height: 1.6;">
<li style="line-height: 1.6;"><code style="font-family: Menlo, Monaco, Consolas, Courier New, monospace; font-size: 90%; padding: 0 4px; color: #c7254e; background-color: #f9f2f4; white-space: nowrap; border-radius: 8px; margin: 0 4px;">LoadLoad</code></li>
<li style="line-height: 1.6;"><code style="font-family: Menlo, Monaco, Consolas, Courier New, monospace; font-size: 90%; padding: 0 4px; color: #c7254e; background-color: #f9f2f4; white-space: nowrap; border-radius: 8px; margin: 0 4px;">LoadStore</code></li>
<li style="line-height: 1.6;"><code style="font-family: Menlo, Monaco, Consolas, Courier New, monospace; font-size: 90%; padding: 0 4px; color: #c7254e; background-color: #f9f2f4; white-space: nowrap; border-radius: 8px; margin: 0 4px;">StoreStore</code></li>
<li style="line-height: 1.6;"><p style="margin: 0 0 10px; line-height: 1.6; white-space: pre-wrap; word-wrap: break-word;"><code style="font-family: Menlo, Monaco, Consolas, Courier New, monospace; font-size: 90%; padding: 0 4px; color: #c7254e; background-color: #f9f2f4; white-space: nowrap; border-radius: 8px; margin: 0 4px;">StoreLoad</code></p>
<p style="margin: 0 0 10px; line-height: 1.6; white-space: pre-wrap; word-wrap: break-word;"> <code style="font-family: Menlo, Monaco, Consolas, Courier New, monospace; font-size: 90%; padding: 0 4px; color: #c7254e; background-color: #f9f2f4; white-space: nowrap; border-radius: 8px; margin: 0 4px;">StoreLoad</code>乱序可能导致所谓的 <strong style="font-weight: bold;">可见性</strong> 问题，对同一个内存地址的访问，某些 CPU 在执行 <code style="font-family: Menlo, Monaco, Consolas, Courier New, monospace; font-size: 90%; padding: 0 4px; color: #c7254e; background-color: #f9f2f4; white-space: nowrap; border-radius: 8px; margin: 0 4px;">Load</code> 时允许直接从 StoreBuffer 中取其最近一次的 <code style="font-family: Menlo, Monaco, Consolas, Courier New, monospace; font-size: 90%; padding: 0 4px; color: #c7254e; background-color: #f9f2f4; white-space: nowrap; border-radius: 8px; margin: 0 4px;">Store</code> 返回，显然这可能导致拿到过时的数据；注意，前提是两次指令 <strong style="font-weight: bold;">访问同一个地址</strong>。 </p>
<p style="margin: 0 0 10px; line-height: 1.6; white-space: pre-wrap; word-wrap: break-word;"> 当前所有主流 CPU 对 <code style="font-family: Menlo, Monaco, Consolas, Courier New, monospace; font-size: 90%; padding: 0 4px; color: #c7254e; background-color: #f9f2f4; white-space: nowrap; border-radius: 8px; margin: 0 4px;">StoreLoad barrier</code> 的实现都包括了其他3个 barrier 的效果（这不是必须的，只是现实如此），因此，<code style="font-family: Menlo, Monaco, Consolas, Courier New, monospace; font-size: 90%; padding: 0 4px; color: #c7254e; background-color: #f9f2f4; white-space: nowrap; border-radius: 8px; margin: 0 4px;">StoreLoad barrier</code> 通常也被当做 <code style="font-family: Menlo, Monaco, Consolas, Courier New, monospace; font-size: 90%; padding: 0 4px; color: #c7254e; background-color: #f9f2f4; white-space: nowrap; border-radius: 8px; margin: 0 4px;">Full Barrier</code> 使用。</p>
</li>
</ol>
<p style="margin: 0 0 10px; line-height: 1.6; white-space: pre-wrap; word-wrap: break-word;">使用标志位是不同的线程间进行通信的一种常见手段，此时需要借助 Memory Barrier 保证多线程间的有序性。一个简单的例子如下：</p>
<pre style="overflow: initial; font-family: Menlo, Monaco, Consolas, Courier New, monospace; font-size: 14px; display: block; padding: 0; margin: 0 0 10px; line-height: 1.6; word-break: break-all; word-wrap: break-word; color: #333333; background-color: #f5f5f5; border: none; border-radius: 0; white-space: pre-wrap; background: transparent;" xml:space="preserve"><code style="font-family: Menlo, Monaco, Consolas, Courier New, monospace; font-size: inherit; padding: 1em; color: #f8f8f2; background-color: transparent; white-space: pre-wrap; border-radius: 8px; display: block; background: #23241f; margin: 0 4px;"><span style="color: #75715e;">// 初始状态</span>
a = <span style="color: #ae81ff;">0</span>;
ready = <span style="color: #ae81ff;">false</span>;

<span style="color: #75715e;">// Thread 1</span>
a = <span style="color: #ae81ff;">1</span>;
ready = <span style="color: #ae81ff;">true</span>;

<span style="color: #75715e;">// Thread 2</span>
<span style="color: #F92672;">if</span>(ready)
    print a  <span style="color: #75715e;">// 可能打印0</span>
<span style="color: #75715e;">/* 
或者：
c = ready
d = a; 
*/</span>
</code></pre>
<p style="margin: 0 0 10px; line-height: 1.6; white-space: pre-wrap; word-wrap: break-word;">在这个例子中，Thread 1试图用 ready 传递 a 已经被赋值的信号，但是存在两个问题：</p>
<ol style="margin-top: 0; margin-bottom: 10px; line-height: 1.6;">
<li style="line-height: 1.6;">Thread 1 对 a 和 ready 的<code style="font-family: Menlo, Monaco, Consolas, Courier New, monospace; font-size: 90%; padding: 0 4px; color: #c7254e; background-color: #f9f2f4; white-space: nowrap; border-radius: 8px; margin: 0 4px;">Store</code>动作有可能<code style="font-family: Menlo, Monaco, Consolas, Courier New, monospace; font-size: 90%; padding: 0 4px; color: #c7254e; background-color: #f9f2f4; white-space: nowrap; border-radius: 8px; margin: 0 4px;">StoreStore</code>乱序，导致 ready 为 true 时，Thread 2看到的 a 依然是0。因此，在 Thread 1 中必须在 a 和 ready 的store 动作之间插入 <code style="font-family: Menlo, Monaco, Consolas, Courier New, monospace; font-size: 90%; padding: 0 4px; color: #c7254e; background-color: #f9f2f4; white-space: nowrap; border-radius: 8px; margin: 0 4px;">StoreStore barrier</code>，保证外部在看到 ready 为 true 时，a 必然已被修改；</li>
<li style="line-height: 1.6;">即使 Thread 1 保证了 Store 有序，Thread 2 依然可能发生 <code style="font-family: Menlo, Monaco, Consolas, Courier New, monospace; font-size: 90%; padding: 0 4px; color: #c7254e; background-color: #f9f2f4; white-space: nowrap; border-radius: 8px; margin: 0 4px;">LoadLoad</code> 乱序。对 a 的 Load 操作可能发生在 ready 的 Load 之前，因此下面的执行顺序是有可能的：<pre style="overflow: initial; font-family: Menlo, Monaco, Consolas, Courier New, monospace; font-size: 14px; display: block; padding: 0; margin: 0 0 10px; line-height: 1.6; word-break: break-all; word-wrap: break-word; color: #333333; background-color: #f5f5f5; border: none; border-radius: 0; white-space: pre-wrap; background: transparent;" xml:space="preserve"><code style="font-family: Menlo, Monaco, Consolas, Courier New, monospace; font-size: inherit; padding: 1em; color: #f8f8f2; background-color: transparent; white-space: pre-wrap; border-radius: 8px; display: block; background: #23241f; margin: 0 4px;">Thread 1                Thread 2
=========               ===========
                         <span><span style="color: #F92672;">Load</span> a  (<span style="color: #ae81ff;">0</span>)
a = <span style="color: #ae81ff;">1</span>
&lt;StoreStore barrier&gt;
ready = <span style="color: #F92672;">true</span>
                         <span style="color: #F92672;">Load</span> ready (<span style="color: #F92672;">true</span>)
                         判断通过
                         print a</span>
</code></pre>
因此，在 Thread 2 中必须用<code style="font-family: Menlo, Monaco, Consolas, Courier New, monospace; font-size: 90%; padding: 0 4px; color: #c7254e; background-color: #f9f2f4; white-space: nowrap; border-radius: 8px; margin: 0 4px;">LoadLoad barrier</code>保证 a 和 ready 两个 Load 动作的顺序性。</li>
</ol>
<p style="margin: 0 0 10px; line-height: 1.6; white-space: pre-wrap; word-wrap: break-word;">由此可见，内存屏障 <strong style="font-weight: bold;">只能保证执行该屏障的 CPU 的内存顺序性</strong>，如果两个线程依赖读写某些相同变量进行通信，只在某一端使用屏障是不够的，另一端也必须根据自己的逻辑加上对应的内存屏障。</p>
<h3 style="font-family: inherit; font-weight: bold; line-height: 1.1; color: inherit; margin-top: 30px; margin-bottom: 20px; font-size: 24px;">3.4 硬件内存模型</h3>
<p style="margin: 0 0 10px; line-height: 1.6; white-space: pre-wrap; word-wrap: break-word;"><code style="font-family: Menlo, Monaco, Consolas, Courier New, monospace; font-size: 90%; padding: 0 4px; color: #c7254e; background-color: #f9f2f4; white-space: nowrap; border-radius: 8px; margin: 0 4px;">Memory Model</code>指定了 CPU 允许哪些指令重排序的发生，越多，内存一致性越弱；越少，内存一致性就越强。</p>
<p style="margin: 0 0 10px; line-height: 1.6; white-space: pre-wrap; word-wrap: break-word;"><img alt="Alt text" class="en-media" longdesc="./1403942010009.png" name="d0cb91ea-2429-4fbb-a241-85a67bea3aa6" src="/assets/img/3f85cd91f478831a157afc5179bccf2b.png" style="border: 0; max-width: 100%; border-radius: 8px;"/></p>
<p style="margin: 0 0 10px; line-height: 1.6; white-space: pre-wrap; word-wrap: break-word;">常见的 x86 平台只允许 <code style="font-family: Menlo, Monaco, Consolas, Courier New, monospace; font-size: 90%; padding: 0 4px; color: #c7254e; background-color: #f9f2f4; white-space: nowrap; border-radius: 8px; margin: 0 4px;">StoreLoad</code> 乱序，因此它的内存模型属于强一致性。</p>
<p style="margin: 0 0 10px; line-height: 1.6; white-space: pre-wrap; word-wrap: break-word;">不同平台上这四种 memory barrier 对应的指令如下，其中 x86 因为只支持<code style="font-family: Menlo, Monaco, Consolas, Courier New, monospace; font-size: 90%; padding: 0 4px; color: #c7254e; background-color: #f9f2f4; white-space: nowrap; border-radius: 8px; margin: 0 4px;">StoreLoad</code>乱序，所以只提供了<code style="font-family: Menlo, Monaco, Consolas, Courier New, monospace; font-size: 90%; padding: 0 4px; color: #c7254e; background-color: #f9f2f4; white-space: nowrap; border-radius: 8px; margin: 0 4px;">StoreLoad Barrier (亦即Full Barrier)</code>:<br/><img alt="Alt text" class="en-media" longdesc="./1403942922620.png" name="02590cd0-d583-4bc4-b7fd-f6fbd78c6c78" src="/assets/img/aaddce10fc3455e3fdc05bca8e83ff62.png" style="border: 0; max-width: 100%; border-radius: 8px;"/></p>
<h3 style="font-family: inherit; font-weight: bold; line-height: 1.1; color: inherit; margin-top: 30px; margin-bottom: 20px; font-size: 24px;">3.5 <code style="font-family: Menlo, Monaco, Consolas, Courier New, monospace; font-size: 90%; padding: 0 4px; color: #c7254e; background-color: #f9f2f4; white-space: nowrap; border-radius: 8px; margin: 0 4px;">Read-Acquire barrier</code> 和 <code style="font-family: Menlo, Monaco, Consolas, Courier New, monospace; font-size: 90%; padding: 0 4px; color: #c7254e; background-color: #f9f2f4; white-space: nowrap; border-radius: 8px; margin: 0 4px;">Write-Release barrier</code></h3>
<p style="margin: 0 0 10px; line-height: 1.6; white-space: pre-wrap; word-wrap: break-word;">在实际应用中，4种按乱序情况的分法太细粒度了，<code style="font-family: Menlo, Monaco, Consolas, Courier New, monospace; font-size: 90%; padding: 0 4px; color: #c7254e; background-color: #f9f2f4; white-space: nowrap; border-radius: 8px; margin: 0 4px;">Read-Acquire barrier</code> 、 <code style="font-family: Menlo, Monaco, Consolas, Courier New, monospace; font-size: 90%; padding: 0 4px; color: #c7254e; background-color: #f9f2f4; white-space: nowrap; border-radius: 8px; margin: 0 4px;">Write-Release barrier</code> 是一种更粗粒度，也更常用的分类方式；</p>
<p style="margin: 0 0 10px; line-height: 1.6; white-space: pre-wrap; word-wrap: break-word;"><img alt="Alt text" class="en-media" longdesc="./1403943796180.png" name="8969be04-7e20-4a15-8b1c-743a04539398" src="/assets/img/41491455e62a0c75bf08d2d5c155ddc3.png" style="border: 0; max-width: 100%; border-radius: 8px;"/></p>
<p style="margin: 0 0 10px; line-height: 1.6; white-space: pre-wrap; word-wrap: break-word;">即：</p>
<ul style="margin-top: 0; margin-bottom: 10px; line-height: 1.6;">
<li style="line-height: 1.6;">Read-Acquire = LoadLoad + LoadStore;</li>
<li style="line-height: 1.6;">Write-Release = LoadStore + StoreStore.</li>
</ul>
<p style="margin: 0 0 10px; line-height: 1.6; white-space: pre-wrap; word-wrap: break-word;"><code style="font-family: Menlo, Monaco, Consolas, Courier New, monospace; font-size: 90%; padding: 0 4px; color: #c7254e; background-color: #f9f2f4; white-space: nowrap; border-radius: 8px; margin: 0 4px;">Read-Acquire</code><br/>具有 Read-Acquire 语义的 Read 操作保证，所有后续的读写只有在该 Read 执行完毕后才能执行。</p>
<p style="margin: 0 0 10px; line-height: 1.6; white-space: pre-wrap; word-wrap: break-word;"><code style="font-family: Menlo, Monaco, Consolas, Courier New, monospace; font-size: 90%; padding: 0 4px; color: #c7254e; background-color: #f9f2f4; white-space: nowrap; border-radius: 8px; margin: 0 4px;">Write-Release</code><br/>具有 Write-Release 语义的 Write 操作保证，只有之前的所有读写都已经执行完毕，该 write 才能执行。</p>
<p style="margin: 0 0 10px; line-height: 1.6; white-space: pre-wrap; word-wrap: break-word;"><code style="font-family: Menlo, Monaco, Consolas, Courier New, monospace; font-size: 90%; padding: 0 4px; color: #c7254e; background-color: #f9f2f4; white-space: nowrap; border-radius: 8px; margin: 0 4px;">Read-Acquire barrier</code> 和 <code style="font-family: Menlo, Monaco, Consolas, Courier New, monospace; font-size: 90%; padding: 0 4px; color: #c7254e; background-color: #f9f2f4; white-space: nowrap; border-radius: 8px; margin: 0 4px;">Write-Release barrier</code> 总是成对使用的，<strong style="font-weight: bold;">保证不同线程间对内存操作的顺序性</strong>：</p>
<p style="margin: 0 0 10px; line-height: 1.6; white-space: pre-wrap; word-wrap: break-word;"><img alt="Alt text" class="en-media" longdesc="./1403959603491.png" name="c9a6da91-e94d-4935-87d2-44b713c9ab6b" src="/assets/img/43fe44f8dfcd17efb0a19880fd8d7c2d.png" style="border: 0; max-width: 100%; border-radius: 8px;"/></p>
<p style="margin: 0 0 10px; line-height: 1.6; white-space: pre-wrap; word-wrap: break-word;">还是举上面的例子，用<code style="font-family: Menlo, Monaco, Consolas, Courier New, monospace; font-size: 90%; padding: 0 4px; color: #c7254e; background-color: #f9f2f4; white-space: nowrap; border-radius: 8px; margin: 0 4px;">Read-Acquire</code>和<code style="font-family: Menlo, Monaco, Consolas, Courier New, monospace; font-size: 90%; padding: 0 4px; color: #c7254e; background-color: #f9f2f4; white-space: nowrap; border-radius: 8px; margin: 0 4px;">Write-Release</code> barrier 的方式如下：</p>
<pre style="overflow: initial; font-family: Menlo, Monaco, Consolas, Courier New, monospace; font-size: 14px; display: block; padding: 0; margin: 0 0 10px; line-height: 1.6; word-break: break-all; word-wrap: break-word; color: #333333; background-color: #f5f5f5; border: none; border-radius: 0; white-space: pre-wrap; background: transparent;" xml:space="preserve"><code style="font-family: Menlo, Monaco, Consolas, Courier New, monospace; font-size: inherit; padding: 1em; color: #f8f8f2; background-color: transparent; white-space: pre-wrap; border-radius: 8px; display: block; background: #23241f; margin: 0 4px;"><span style="color: #75715e;">// 初始状态</span>
a = <span style="color: #ae81ff;">0</span>;
ready = <span style="color: #F92672;">false</span>;

<span style="color: #75715e;">// Thread 1</span>
a = <span style="color: #ae81ff;">1</span>;
write_release_barrier();
ready = <span style="color: #F92672;">true</span>;

<span style="color: #75715e;">// Thread 2</span>
<span style="color: #F92672;">if</span>(ready){
    read_acquire_barrier();    
    print a
}
</code></pre>
<p style="margin: 0 0 10px; line-height: 1.6; white-space: pre-wrap; word-wrap: break-word;">此时，我们 <strong style="font-weight: bold;">为 ready 这个变量赋予了 <code style="font-family: Menlo, Monaco, Consolas, Courier New, monospace; font-size: 90%; padding: 0 4px; color: #c7254e; background-color: #f9f2f4; white-space: nowrap; border-radius: 8px; margin: 0 4px;">Read-Acquire</code> 和 <code style="font-family: Menlo, Monaco, Consolas, Courier New, monospace; font-size: 90%; padding: 0 4px; color: #c7254e; background-color: #f9f2f4; white-space: nowrap; border-radius: 8px; margin: 0 4px;">Write-Release</code> 语义</strong>，对它的读或写动作与前后的其他 load/store 动作确立了先后关系. 当 Thread 2 发现 ready 为 true 时，a 的 store 必然已经完成，必然为1; 而 a 的 load 也不会比 ready 的 load 先完成.</p>
<p style="margin: 0 0 10px; line-height: 1.6; white-space: pre-wrap; word-wrap: break-word;"><code style="font-family: Menlo, Monaco, Consolas, Courier New, monospace; font-size: 90%; padding: 0 4px; color: #c7254e; background-color: #f9f2f4; white-space: nowrap; border-radius: 8px; margin: 0 4px;">Read-Acquire</code> 和 <code style="font-family: Menlo, Monaco, Consolas, Courier New, monospace; font-size: 90%; padding: 0 4px; color: #c7254e; background-color: #f9f2f4; white-space: nowrap; border-radius: 8px; margin: 0 4px;">Write-Release</code> 语义也被广泛应用在锁的实现中，<strong style="font-weight: bold;">加锁 和 释放锁 分别附带了<code style="font-family: Menlo, Monaco, Consolas, Courier New, monospace; font-size: 90%; padding: 0 4px; color: #c7254e; background-color: #f9f2f4; white-space: nowrap; border-radius: 8px; margin: 0 4px;">Read-Acquire</code> 和 <code style="font-family: Menlo, Monaco, Consolas, Courier New, monospace; font-size: 90%; padding: 0 4px; color: #c7254e; background-color: #f9f2f4; white-space: nowrap; border-radius: 8px; margin: 0 4px;">Write-Release</code> 语义，保证了 <code style="font-family: Menlo, Monaco, Consolas, Courier New, monospace; font-size: 90%; padding: 0 4px; color: #c7254e; background-color: #f9f2f4; white-space: nowrap; border-radius: 8px; margin: 0 4px;">加锁 --&gt; load/store</code> 和 <code style="font-family: Menlo, Monaco, Consolas, Courier New, monospace; font-size: 90%; padding: 0 4px; color: #c7254e; background-color: #f9f2f4; white-space: nowrap; border-radius: 8px; margin: 0 4px;">load/store --&gt; 释放锁</code> 这两个指令序列之间的偏序关系</strong>，这样当某个线程获取了锁时，它可以确信前一个线程在释放锁之前所做的操作已经全部完成了。</p>
<p style="margin: 0 0 10px; line-height: 1.6; white-space: pre-wrap; word-wrap: break-word;">接下来会看到，<code style="font-family: Menlo, Monaco, Consolas, Courier New, monospace; font-size: 90%; padding: 0 4px; color: #c7254e; background-color: #f9f2f4; white-space: nowrap; border-radius: 8px; margin: 0 4px;">Read-Acquire</code> 和 <code style="font-family: Menlo, Monaco, Consolas, Courier New, monospace; font-size: 90%; padding: 0 4px; color: #c7254e; background-color: #f9f2f4; white-space: nowrap; border-radius: 8px; margin: 0 4px;">Write-Release</code> 是 JMM 的核心。</p>
<h3 style="font-family: inherit; font-weight: bold; line-height: 1.1; color: inherit; margin-top: 30px; margin-bottom: 20px; font-size: 24px;">3.6 JMM 对 CPU Memory Reordering 的规则</h3>
<p style="margin: 0 0 10px; line-height: 1.6; white-space: pre-wrap; word-wrap: break-word;">JMM 定义了单线程内必须遵循如下重排序规则：</p>
<table style="border-collapse: collapse; border-spacing: 0; margin-bottom: 20px;">
<thead>
<tr>
<th style="padding: 8px; line-height: 20px; text-align: left; vertical-align: top; border: 1px solid #DDD;"></th>
<th style="text-align: center; padding: 8px; line-height: 20px; vertical-align: top; border: 1px solid #DDD;">NormalLoad</th>
<th style="text-align: center; padding: 8px; line-height: 20px; vertical-align: top; border: 1px solid #DDD;">NormalStore</th>
<th style="text-align: center; padding: 8px; line-height: 20px; vertical-align: top; border: 1px solid #DDD;">VolatileLoad / MonitorEnter</th>
<th style="text-align: center; padding: 8px; line-height: 20px; vertical-align: top; border: 1px solid #DDD;">VolatileStore / MonitorExit</th>
</tr>
</thead>
<tbody>
<tr>
<td style="padding: 8px; line-height: 20px; text-align: left; vertical-align: top; border: 1px solid #DDD;">NormalLoad</td>
<td style="text-align: center; padding: 8px; line-height: 20px; vertical-align: top; border: 1px solid #DDD;"></td>
<td style="text-align: center; padding: 8px; line-height: 20px; vertical-align: top; border: 1px solid #DDD;"></td>
<td style="text-align: center; padding: 8px; line-height: 20px; vertical-align: top; border: 1px solid #DDD;"></td>
<td style="text-align: center; padding: 8px; line-height: 20px; vertical-align: top; border: 1px solid #DDD;"><strong style="font-weight: bold;">LoadStore</strong></td>
</tr>
<tr>
<td style="padding: 8px; line-height: 20px; text-align: left; vertical-align: top; border: 1px solid #DDD;">NomalStore</td>
<td style="text-align: center; padding: 8px; line-height: 20px; vertical-align: top; border: 1px solid #DDD;"></td>
<td style="text-align: center; padding: 8px; line-height: 20px; vertical-align: top; border: 1px solid #DDD;"></td>
<td style="text-align: center; padding: 8px; line-height: 20px; vertical-align: top; border: 1px solid #DDD;"></td>
<td style="text-align: center; padding: 8px; line-height: 20px; vertical-align: top; border: 1px solid #DDD;"><strong style="font-weight: bold;">StoreStore</strong></td>
</tr>
<tr>
<td style="padding: 8px; line-height: 20px; text-align: left; vertical-align: top; border: 1px solid #DDD;">VolatileLoad / MonitorEnter</td>
<td style="text-align: center; padding: 8px; line-height: 20px; vertical-align: top; border: 1px solid #DDD;">LoadLoad</td>
<td style="text-align: center; padding: 8px; line-height: 20px; vertical-align: top; border: 1px solid #DDD;">LoadStore</td>
<td style="text-align: center; padding: 8px; line-height: 20px; vertical-align: top; border: 1px solid #DDD;">LoadLoad</td>
<td style="text-align: center; padding: 8px; line-height: 20px; vertical-align: top; border: 1px solid #DDD;"><strong style="font-weight: bold;">LoadStore</strong></td>
</tr>
<tr>
<td style="padding: 8px; line-height: 20px; text-align: left; vertical-align: top; border: 1px solid #DDD;">VolatileStore / MonitorExit</td>
<td style="text-align: center; padding: 8px; line-height: 20px; vertical-align: top; border: 1px solid #DDD;"></td>
<td style="text-align: center; padding: 8px; line-height: 20px; vertical-align: top; border: 1px solid #DDD;"></td>
<td style="text-align: center; padding: 8px; line-height: 20px; vertical-align: top; border: 1px solid #DDD;"><code style="font-family: Menlo, Monaco, Consolas, Courier New, monospace; font-size: 90%; padding: 0 4px; color: #c7254e; background-color: #f9f2f4; white-space: nowrap; border-radius: 8px; margin: 0 4px;">StoreLoad</code></td>
<td style="text-align: center; padding: 8px; line-height: 20px; vertical-align: top; border: 1px solid #DDD;"><strong style="font-weight: bold;">StoreStore</strong></td>
</tr>
</tbody>
</table>
<p style="margin: 0 0 10px; line-height: 1.6; white-space: pre-wrap; word-wrap: break-word;">看上去很复杂，但其实只有两点：</p>
<ol style="margin-top: 0; margin-bottom: 10px; line-height: 1.6;">
<li style="line-height: 1.6;"><p style="margin: 0 0 10px; line-height: 1.6; white-space: pre-wrap; word-wrap: break-word;"><strong style="font-weight: bold;"> <code style="font-family: Menlo, Monaco, Consolas, Courier New, monospace; font-size: 90%; padding: 0 4px; color: #c7254e; background-color: #f9f2f4; white-space: nowrap; border-radius: 8px; margin: 0 4px;">Volatile</code> 变量 / <code style="font-family: Menlo, Monaco, Consolas, Courier New, monospace; font-size: 90%; padding: 0 4px; color: #c7254e; background-color: #f9f2f4; white-space: nowrap; border-radius: 8px; margin: 0 4px;">Monitor</code>具有 <code style="font-family: Menlo, Monaco, Consolas, Courier New, monospace; font-size: 90%; padding: 0 4px; color: #c7254e; background-color: #f9f2f4; white-space: nowrap; border-radius: 8px; margin: 0 4px;">Read-Acquire &amp; Write-Release</code> 语义； </strong></p>
<p style="margin: 0 0 10px; line-height: 1.6; white-space: pre-wrap; word-wrap: break-word;"> 第三行即 <code style="font-family: Menlo, Monaco, Consolas, Courier New, monospace; font-size: 90%; padding: 0 4px; color: #c7254e; background-color: #f9f2f4; white-space: nowrap; border-radius: 8px; margin: 0 4px;">Read-Acquire</code>，最后一列即 <code style="font-family: Menlo, Monaco, Consolas, Courier New, monospace; font-size: 90%; padding: 0 4px; color: #c7254e; background-color: #f9f2f4; white-space: nowrap; border-radius: 8px; margin: 0 4px;">Write-Release</code>；</p>
</li>
<li style="line-height: 1.6;"><p style="margin: 0 0 10px; line-height: 1.6; white-space: pre-wrap; word-wrap: break-word;"><strong style="font-weight: bold;"> 在任意两个 <code style="font-family: Menlo, Monaco, Consolas, Courier New, monospace; font-size: 90%; padding: 0 4px; color: #c7254e; background-color: #f9f2f4; white-space: nowrap; border-radius: 8px; margin: 0 4px;">Volatile</code> 变量 / <code style="font-family: Menlo, Monaco, Consolas, Courier New, monospace; font-size: 90%; padding: 0 4px; color: #c7254e; background-color: #f9f2f4; white-space: nowrap; border-radius: 8px; margin: 0 4px;">Monitor</code> 的 <code style="font-family: Menlo, Monaco, Consolas, Courier New, monospace; font-size: 90%; padding: 0 4px; color: #c7254e; background-color: #f9f2f4; white-space: nowrap; border-radius: 8px; margin: 0 4px;">Store-&gt;Load</code> / <code style="font-family: Menlo, Monaco, Consolas, Courier New, monospace; font-size: 90%; padding: 0 4px; color: #c7254e; background-color: #f9f2f4; white-space: nowrap; border-radius: 8px; margin: 0 4px;">Exit-&gt;Enter</code> 操作中间必须插入一个 <code style="font-family: Menlo, Monaco, Consolas, Courier New, monospace; font-size: 90%; padding: 0 4px; color: #c7254e; background-color: #f9f2f4; white-space: nowrap; border-radius: 8px; margin: 0 4px;">StoreLoad</code> barrier 禁止重排序; 这同时也解决了单个 volatile 变量 / Monitor 可能出现的可见性问题 。</strong></p>
<p style="margin: 0 0 10px; line-height: 1.6; white-space: pre-wrap; word-wrap: break-word;"> 可见性问题已经在3.3描述过了.</p>
</li>
</ol>
<p style="margin: 0 0 10px; line-height: 1.6; white-space: pre-wrap; word-wrap: break-word;"><img alt="Alt text" class="en-media" longdesc="./1403963190097.png" name="b09cfb74-f1f3-43c7-9cd4-589f12e443f9" src="/assets/img/76c4cf48eb5fc3fc8f6dde0593ee85ef.png" style="border: 0; max-width: 100%; border-radius: 8px;"/></p>
<p style="margin: 0 0 10px; line-height: 1.6; white-space: pre-wrap; word-wrap: break-word;">JMM cookbook 中提到了一种可能的实现。编译器很多时候无法知道确切的<code style="font-family: Menlo, Monaco, Consolas, Courier New, monospace; font-size: 90%; padding: 0 4px; color: #c7254e; background-color: #f9f2f4; white-space: nowrap; border-radius: 8px; margin: 0 4px;">Load</code> / <code style="font-family: Menlo, Monaco, Consolas, Courier New, monospace; font-size: 90%; padding: 0 4px; color: #c7254e; background-color: #f9f2f4; white-space: nowrap; border-radius: 8px; margin: 0 4px;">Store</code> 指令顺序，比如在一个方法 return 之前对一个 Volatile 变量 write 了，因此一个策略是采取悲观策略，在每个可能需要禁止某种重排序的地方都加上对应的 barrier：</p>
<ol style="margin-top: 0; margin-bottom: 10px; line-height: 1.6;">
<li style="line-height: 1.6;">在每个 <code style="font-family: Menlo, Monaco, Consolas, Courier New, monospace; font-size: 90%; padding: 0 4px; color: #c7254e; background-color: #f9f2f4; white-space: nowrap; border-radius: 8px; margin: 0 4px;">Volatile Read / Monitor Enter</code> 后加上 <code style="font-family: Menlo, Monaco, Consolas, Courier New, monospace; font-size: 90%; padding: 0 4px; color: #c7254e; background-color: #f9f2f4; white-space: nowrap; border-radius: 8px; margin: 0 4px;">LoadLoad</code> &amp; <code style="font-family: Menlo, Monaco, Consolas, Courier New, monospace; font-size: 90%; padding: 0 4px; color: #c7254e; background-color: #f9f2f4; white-space: nowrap; border-radius: 8px; margin: 0 4px;">LoadStore</code> barrier，亦即 <code style="font-family: Menlo, Monaco, Consolas, Courier New, monospace; font-size: 90%; padding: 0 4px; color: #c7254e; background-color: #f9f2f4; white-space: nowrap; border-radius: 8px; margin: 0 4px;">Read-Acquire</code> barrier;</li>
<li style="line-height: 1.6;">在每个 <code style="font-family: Menlo, Monaco, Consolas, Courier New, monospace; font-size: 90%; padding: 0 4px; color: #c7254e; background-color: #f9f2f4; white-space: nowrap; border-radius: 8px; margin: 0 4px;">Volatile Write / Monitor Exit</code> 前加上 <code style="font-family: Menlo, Monaco, Consolas, Courier New, monospace; font-size: 90%; padding: 0 4px; color: #c7254e; background-color: #f9f2f4; white-space: nowrap; border-radius: 8px; margin: 0 4px;">StoreStore</code> &amp; <code style="font-family: Menlo, Monaco, Consolas, Courier New, monospace; font-size: 90%; padding: 0 4px; color: #c7254e; background-color: #f9f2f4; white-space: nowrap; border-radius: 8px; margin: 0 4px;">LoadStore</code> barrier，亦即 <code style="font-family: Menlo, Monaco, Consolas, Courier New, monospace; font-size: 90%; padding: 0 4px; color: #c7254e; background-color: #f9f2f4; white-space: nowrap; border-radius: 8px; margin: 0 4px;">Write-Release</code> barrier;</li>
<li style="line-height: 1.6;">在每个 <code style="font-family: Menlo, Monaco, Consolas, Courier New, monospace; font-size: 90%; padding: 0 4px; color: #c7254e; background-color: #f9f2f4; white-space: nowrap; border-radius: 8px; margin: 0 4px;">Volatile Write / Monitor Exit</code> 后加上 <code style="font-family: Menlo, Monaco, Consolas, Courier New, monospace; font-size: 90%; padding: 0 4px; color: #c7254e; background-color: #f9f2f4; white-space: nowrap; border-radius: 8px; margin: 0 4px;">StoreLoad</code> barrier（也可以在每次 Read 前加上，但 Write 出现的几率显然要低的多）。</li>
</ol>
<p style="margin: 0 0 10px; line-height: 1.6; white-space: pre-wrap; word-wrap: break-word;">当然，编译器会做许多别的优化，比如合并 barrier 之类的，而且很大一部分的 barrier 对应到硬件指令时是空操作。</p>
<p style="margin: 0 0 10px; line-height: 1.6; white-space: pre-wrap; word-wrap: break-word;">这个策略在 openjdk 的 C1 编译器<a href="https://www.evernote.com/OutboundRedirect.action?dest=https%3A%2F%2Fcode.google.com%2Fp%2Fneedle%2Fsource%2Fbrowse%2Fsrc%2Fshare%2Fvm%2Fc1%2Fc1_LIRGenerator.cpp%3Fr%3D2f644f85485d7460dea5edb5f6c8716093e66a44" style="background: transparent;" target="_blank"> (c1_LIRGenerator.cpp) </a>中得到了印证：</p>
<pre style="overflow: initial; font-family: Menlo, Monaco, Consolas, Courier New, monospace; font-size: 14px; display: block; padding: 0; margin: 0 0 10px; line-height: 1.6; word-break: break-all; word-wrap: break-word; color: #333333; background-color: #f5f5f5; border: none; border-radius: 0; white-space: pre-wrap; background: transparent;" xml:space="preserve"><code style="font-family: Menlo, Monaco, Consolas, Courier New, monospace; font-size: inherit; padding: 1em; color: #f8f8f2; background-color: transparent; white-space: pre-wrap; border-radius: 8px; display: block; background: #23241f; margin: 0 4px;"><span style="color: #75715e;">//------------------------field access--------------------------------------</span>

<span style="color: #75715e;">// Comment copied form templateTable_i486.cpp</span>
<span style="color: #75715e;">// ----------------------------------------------------------------------------</span>
<span style="color: #75715e;">// Volatile variables demand their effects be made known to all CPU's in</span>
<span style="color: #75715e;">// order.  Store buffers on most chips allow reads &amp; writes to reorder; the</span>
<span style="color: #75715e;">// JMM's ReadAfterWrite.java test fails in -Xint mode without some kind of</span>
<span style="color: #75715e;">// memory barrier (i.e., it's not sufficient that the interpreter does not</span>
<span style="color: #75715e;">// reorder volatile references, the hardware also must not reorder them).</span>
<span style="color: #75715e;">//</span>
<span style="color: #75715e;">// According to the new Java Memory Model (JMM):</span>
<span style="color: #75715e;">// (1) All volatiles are serialized wrt to each other.</span>
<span style="color: #75715e;">// ALSO reads &amp; writes act as aquire &amp; release, so:</span>
<span style="color: #75715e;">// (2) A read cannot let unrelated NON-volatile memory refs that happen after</span>
<span style="color: #75715e;">// the read float up to before the read.  It's OK for non-volatile memory refs</span>
<span style="color: #75715e;">// that happen before the volatile read to float down below it.</span>
<span style="color: #75715e;">// (3) Similar a volatile write cannot let unrelated NON-volatile memory refs</span>
<span style="color: #75715e;">// that happen BEFORE the write float down to after the write.  It's OK for</span>
<span style="color: #75715e;">// non-volatile memory refs that happen after the volatile write to float up</span>
<span style="color: #75715e;">// before it.</span>
<span style="color: #75715e;">//</span>
<span style="color: #75715e;">// We only put in barriers around volatile refs (they are expensive), not</span>
<span style="color: #75715e;">// _between_ memory refs (that would require us to track the flavor of the</span>
<span style="color: #75715e;">// previous memory refs).  Requirements (2) and (3) require some barriers</span>
<span style="color: #75715e;">// before volatile stores and after volatile loads.  These nearly cover</span>
<span style="color: #75715e;">// requirement (1) but miss the volatile-store-volatile-load case.  This final</span>
<span style="color: #75715e;">// case is placed after volatile-stores although it could just as well go</span>
<span style="color: #75715e;">// before volatile-loads.</span>

<span style="color: #75715e;">// volatile store</span>
<span style="color: #F92672;">void</span> LIRGenerator::do_StoreField(StoreField* x) {
    <span style="color: #75715e;">// Write-Release barrier</span>
    <span style="color: #F92672;">if</span> (is_volatile &amp;&amp; os::is_MP()) {
        __ membar_release();
    }

    <span style="color: #75715e;">// Store</span>
    ...
    volatile_field_store(value.result(), address, info);
    ...

    <span style="color: #75715e;">// StoreLoad barrier，这里直接写作 membar 的原因是大部分平台上 storeload barrier 被实现为一个 full barrier</span>
    <span style="color: #F92672;">if</span> (is_volatile &amp;&amp; os::is_MP()) {
        __ membar();
    }
}

<span style="color: #75715e;">// volatile load</span>
<span style="color: #F92672;">void</span> LIRGenerator::do_LoadField(LoadField* x) {
    <span style="color: #75715e;">// Load</span>
    ...
    volatile_field_load(address, reg, info);
    ...

    <span style="color: #75715e;">// Read-Acquire barrier</span>
    <span style="color: #F92672;">if</span> (is_volatile &amp;&amp; os::is_MP()) {
        __ membar_acquire();
    }
}
</code></pre>
<h2 style="font-family: inherit; font-weight: bold; line-height: 1.1; color: inherit; margin-top: 30px; margin-bottom: 20px; font-size: 30px;">3. JMM的其他方面</h2>
<ol style="margin-top: 0; margin-bottom: 10px; line-height: 1.6;">
<li style="line-height: 1.6;"><strong style="font-weight: bold;">原子性</strong>，JMM 规定基本类型的 load/store 必须是原子的；</li>
<li style="line-height: 1.6;"><code style="font-family: Menlo, Monaco, Consolas, Courier New, monospace; font-size: 90%; padding: 0 4px; color: #c7254e; background-color: #f9f2f4; white-space: nowrap; border-radius: 8px; margin: 0 4px;">Volatile</code> 变量不允许使用寄存器分配。</li>
<li style="line-height: 1.6;">final 变量??</li>
</ol>
<h2 style="font-family: inherit; font-weight: bold; line-height: 1.1; color: inherit; margin-top: 30px; margin-bottom: 20px; font-size: 30px;">4. 总结</h2>
<ol style="margin-top: 0; margin-bottom: 10px; line-height: 1.6;">
<li style="line-height: 1.6;">什么时候用<code style="font-family: Menlo, Monaco, Consolas, Courier New, monospace; font-size: 90%; padding: 0 4px; color: #c7254e; background-color: #f9f2f4; white-space: nowrap; border-radius: 8px; margin: 0 4px;">volatile</code>? --  当一个变量被多线程访问, 且会被其中某些线程 write 时, 用<code style="font-family: Menlo, Monaco, Consolas, Courier New, monospace; font-size: 90%; padding: 0 4px; color: #c7254e; background-color: #f9f2f4; white-space: nowrap; border-radius: 8px; margin: 0 4px;">volatile</code>.</li>
</ol>
<h2 style="font-family: inherit; font-weight: bold; line-height: 1.1; color: inherit; margin-top: 30px; margin-bottom: 20px; font-size: 30px;">5. 参考资料</h2>
<ol style="margin-top: 0; margin-bottom: 10px; line-height: 1.6;">
<li style="line-height: 1.6;"><a href="http://gee.cs.oswego.edu/dl/jmm/cookbook.html" style="background: transparent;" target="_blank">The JSR-133 Cookbook</a></li>
<li style="line-height: 1.6;">何登成的《CPU Cache and Memory Ordering.ppt》</li>
<li style="line-height: 1.6;"><a href="https://www.evernote.com/OutboundRedirect.action?dest=https%3A%2F%2Fdocs.google.com%2Fpresentation%2Fd%2F1JkOUQ07nr0WQ8SKqcWA5D3M0v1gUdAwgNBbUcMhhGis%2Fpreview%3Fusp%3Dsharing%26sle%3Dtrue%23slide%3Did.p" style="background: transparent;" target="_blank">无锁化编程</a></li>
<li style="line-height: 1.6;"><a href="http://preshing.com/20120913/acquire-and-release-semantics" style="background: transparent;" target="_blank">Acquire and Release Semantics</a></li>
<li style="line-height: 1.6;"><a href="http://preshing.com/20120625/memory-ordering-at-compile-time/" style="background: transparent;" target="_blank">Memory Ordering at Compile Time</a></li>
<li style="line-height: 1.6;"><a href="http://ifeve.com/memory-barriersfences/" style="background: transparent;" target="_blank">Memory Barriers/Fences</a></li>
<li style="line-height: 1.6;"><a href="http://gvsmirnov.ru/blog/tech/2014/02/10/jmm-under-the-hood.html#printassembly-fun" style="background: transparent;" target="_blank">Java Memory Model Under The Hood</a></li>
<li style="line-height: 1.6;"><a href="http://www.linuxjournal.com/article/8212" style="background: transparent;" target="_blank">Memory Ordering in Modern Microprocessors, Part II</a></li>
<li style="line-height: 1.6;"><a href="http://ifeve.com/cpu-cache-flushing-fallacy-cn/" style="background: transparent;" target="_blank">CPU Cache Flushing Fallacy</a></li>
<li style="line-height: 1.6;"><a href="http://preshing.com/20120930/weak-vs-strong-memory-models/" style="background: transparent;" target="_blank">Weak vs. Strong Memory Models</a></li>
<li style="line-height: 1.6;"><a href="http://www.infoq.c/java-memory-model-1" style="background: transparent;" target="_blank">深入理解Java内存模型</a> 系列文章</li>
</ol>
<hr style="-moz-box-sizing: content-box; box-sizing: content-box; height: 0; line-height: 1.6; margin-top: 20px; margin-bottom: 20px; border: 0; border-top: 1px solid rgba(102, 128, 153, 0.15);"/>
<p style="margin: 0 0 10px; line-height: 1.6; white-space: pre-wrap; word-wrap: break-word;">附：<code style="font-family: Menlo, Monaco, Consolas, Courier New, monospace; font-size: 90%; padding: 0 4px; color: #c7254e; background-color: #f9f2f4; white-space: nowrap; border-radius: 8px; margin: 0 4px;">StoreLoad</code> 乱序导致 <code style="font-family: Menlo, Monaco, Consolas, Courier New, monospace; font-size: 90%; padding: 0 4px; color: #c7254e; background-color: #f9f2f4; white-space: nowrap; border-radius: 8px; margin: 0 4px;">Peterson 算法</code> 失效<br/>这不属于通用问题，而是依赖代码的逻辑。</p>
</div>